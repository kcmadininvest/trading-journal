{
  "rules": [
    {
      "id": "expertise",
      "description": "You are an expert in React, Vite, Tailwind CSS, three.js, React Three Fiber, and Next UI.",
      "action": "enforce",
      "target": "general"
    },
    {
      "id": "key_principles",
      "description": "Adhere to key React and code quality principles.",
      "action": "enforce",
      "details": {
        "conciseness": "Write concise, technical responses with accurate React examples.",
        "style": "Use functional, declarative programming. Avoid classes.",
        "modularity": "Prefer iteration and modularization over duplication.",
        "naming": "Use descriptive variable names with auxiliary verbs (e.g., isLoading).",
        "directories": "Use lowercase with dashes for directories (e.g., components/auth-wizard).",
        "exports": "Favor named exports for components.",
        "pattern": "Use the Receive an Object, Return an Object (RORO) pattern."
      }
    },
    {
      "id": "architecture_improvements",
      "description": "Recommended improvements for project structure and routing.",
      "action": "advise",
      "details": {
        "component_size": "Ensure each component has a single responsibility. If a component exceeds 150 lines, split it into subcomponents.",
        "folder_depth": "Avoid deeply nested folders. Keep a maximum depth of 3.",
        "routing": "Use a clear routing structure with react-router-dom or @tanstack/router for modern navigation handling."
      }
    },
    {
      "id": "state_management",
      "description": "Follow best practices for application state management.",
      "action": "enforce",
      "details": {
        "patterns": "You can continue using Pinia-like patterns, or adopt Zustand, Jotai, or TanStack Query for asynchronous data.",
        "tanstack_query": "Use TanStack Query (React Query) for frequent API calls and caching.",
        "avoid_volatile": "Avoid storing volatile UI state (e.g., isOpen, hovered) in the global store.",
        "hooks": "Centralize network requests and business logic into dedicated hooks (e.g., useFetchUser, usePortfolioData).",
        "three_integration": "If using Three.js or React Three Fiber, isolate the canvas state into a dedicated store (for cameras, meshes, materials, etc.)."
      }
    },
    {
      "id": "javascript_typescript",
      "description": "Follow JavaScript and TypeScript best practices.",
      "action": "enforce",
      "details": {
        "functions": "Use 'function' keyword for pure functions. Omit semicolons.",
        "typescript": "Use TypeScript for all code. Prefer interfaces over types. Avoid enums, use maps.",
        "structure": "File structure should include exported component, subcomponents, helpers, static content, and types.",
        "curly_braces": "Avoid unnecessary curly braces in conditional statements. For single-line statements, omit curly braces.",
        "concise_conditionals": "Use concise, one-line syntax for simple conditional statements (e.g., if (condition) doSomething())."
      }
    },
    {
      "id": "error_handling",
      "description": "Prioritize robust error handling and validation.",
      "action": "enforce",
      "details": {
        "ordering": "Handle errors and edge cases at the beginning of functions. Use early returns to avoid deeply nested if statements.",
        "happy_path": "Place the happy path last for better readability.",
        "else_avoidance": "Avoid unnecessary else statements; prefer if-return pattern.",
        "guard_clauses": "Use guard clauses for preconditions and invalid states.",
        "logging": "Implement proper error logging and user-friendly messages.",
        "custom_errors": "Consider using custom error types or error factories for consistency."
      }
    },
    {
      "id": "react_guidelines",
      "description": "Follow React-specific best practices.",
      "action": "enforce",
      "details": {
        "components": "Use functional components and interfaces. Use 'function', not 'const', for components.",
        "jsx": "Use declarative JSX syntax.",
        "styling": "Use Next UI and Tailwind CSS for components and styling. Implement responsive design with a mobile-first approach.",
        "content": "Place static content and interfaces at the end of files. Use content variables outside render functions.",
        "suspense": "Wrap client components in Suspense with fallback.",
        "dynamic_loading": "Use dynamic loading for non-critical components.",
        "images": "Optimize images (WebP format, size data, lazy loading).",
        "error_modeling": "Model expected errors as return values; avoid try/catch for expected errors in Server Actions.",
        "error_boundaries": "Use error boundaries (error.tsx, global-error.tsx) for unexpected errors.",
        "form_validation": "Use useActionState with react-hook-form for form validation.",
        "user_errors": "Always throw user-friendly errors that tanStackQuery can catch and show to the user.",
        "mobile_first": "All design and layout decisions must follow a mobile-first approach."
      }
    },
    {
      "id": "task_summary_behavior",
      "description": "Do not create a markdown (.md) summary file at the end of a task. Instead, provide a concise, readable summary directly within the user panel.",
      "action": "enforce",
      "target": "task_completion"
    }
  ]
}
